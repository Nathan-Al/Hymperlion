
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for Hymperlion/NodeJS/public/semantic/components/sticky.min.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">Hymperlion/NodeJS/public/semantic/components</a> sticky.min.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/133</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/222</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/74</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(T,w,B,P){"use strict";<span class="cstat-no" title="statement not covered" >w=void 0!==w&amp;&amp;w.Math==Math?w:"undefined"!=typeof self&amp;&amp;self.Math==Math?self:Function("return this")(),T.fn.sticky=<span class="fstat-no" title="function not covered" >fu</span>nction(b){var v,e=<span class="cstat-no" title="statement not covered" >T(this),</span>x=<span class="cstat-no" title="statement not covered" >e.selector||"",</span>C=<span class="cstat-no" title="statement not covered" >(new Date).getTime(),</span>S=<span class="cstat-no" title="statement not covered" >[],</span>y=<span class="cstat-no" title="statement not covered" >b,</span>k=<span class="cstat-no" title="statement not covered" >"string"==typeof y,</span>z=<span class="cstat-no" title="statement not covered" >[].slice.call(arguments,1);<span class="cstat-no" title="statement not covered" ></span>return e.each(<span class="fstat-no" title="function not covered" >fu</span>nction(){var n,i,e,t,m,u=<span class="cstat-no" title="statement not covered" >T.isPlainObject(b)?T.extend(!0,{},T.fn.sticky.settings,b):T.extend({},T.fn.sticky.settings),</span>o=<span class="cstat-no" title="statement not covered" >u.className,</span>s=<span class="cstat-no" title="statement not covered" >u.namespace,</span>r=<span class="cstat-no" title="statement not covered" >u.error,</span>c=<span class="cstat-no" title="statement not covered" >"."+s,</span>l=<span class="cstat-no" title="statement not covered" >"module-"+s,</span>a=<span class="cstat-no" title="statement not covered" >T(this),</span>f=<span class="cstat-no" title="statement not covered" >T(w),</span>d=<span class="cstat-no" title="statement not covered" >T(u.scrollContext),</span>h=(<span class="cstat-no" title="statement not covered" >a.selector,a.data(l))</span>,g=<span class="cstat-no" title="statement not covered" >w.requestAnimationFrame||w.mozRequestAnimationFrame||w.webkitRequestAnimationFrame||w.msRequestAnimationFrame||<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >setTimeout(e,0)}</span>,</span>p=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>m={initialize:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.determineContainer(),m.determineContext(),m.verbose("Initializing sticky",u,n),m.save.positions(),m.checkErrors(),m.bind.events(),u.observeChanges&amp;&amp;m.observeChanges(),m.instantiate()}</span>,instantiate:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.verbose("Storing instance of module",m),h=m,a.data(l,m)}</span>,destroy:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.verbose("Destroying previous instance"),m.reset(),e&amp;&amp;e.disconnect(),t&amp;&amp;t.disconnect(),f.off("load"+c,m.event.load).off("resize"+c,m.event.resize),d.off("scrollchange"+c,m.event.scrollchange),a.removeData(l)}</span>,observeChanges:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >"MutationObserver"in w&amp;&amp;(e=new MutationObserver(m.event.documentChanged),t=new MutationObserver(m.event.changed),e.observe(B,{childList:!0,subtree:!0}),t.observe(p,{childList:!0,subtree:!0}),t.observe(i[0],{childList:!0,subtree:!0}),m.debug("Setting up mutation observer",t))}</span>,determineContainer:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n=u.container?T(u.container):a.offsetParent()}</span>,determineContext:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >0!==(i=u.context?T(u.context):n).length||m.error(r.invalidContext,u.context,a)}</span>,checkErrors:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(m.is.hidden()&amp;&amp;m.error(r.visible,a),m.cache.element.height&gt;m.cache.context.height)<span class="cstat-no" title="statement not covered" >return m.reset(),void m.error(r.elementSize,a)}</span></span>,bind:{events:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >f.on("load"+c,m.event.load).on("resize"+c,m.event.resize),d.off("scroll"+c).on("scroll"+c,m.event.scroll).on("scrollchange"+c,m.event.scrollchange)}</span>},event:{changed:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >clearTimeout(m.timer),m.timer=setTimeout(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.verbose("DOM tree modified, updating sticky menu",e),m.refresh()}</span>,100)}</span>,documentChanged:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >[].forEach.call(e,<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.removedNodes&amp;&amp;[].forEach.call(e.removedNodes,<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >(e==p||0&lt;T(e).find(p).length)&amp;&amp;(m.debug("Element removed from DOM, tearing down events"),m.destroy())}</span>)}</span>)}</span>,load:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.verbose("Page contents finished loading"),g(m.refresh)}</span>,resize:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.verbose("Window resized"),g(m.refresh)}</span>,scroll:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >g(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >d.triggerHandler("scrollchange"+c,d.scrollTop())}</span>)}</span>,scrollchange:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >m.stick(t),u.onScroll.call(p)}</span>},refresh:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >m.reset(),u.context||m.determineContext(),e&amp;&amp;m.determineContainer(),m.save.positions(),m.stick(),u.onReposition.call(p)}</span>,supports:{sticky:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >T("&lt;div/&gt;");<span class="cstat-no" title="statement not covered" ></span>e[0];<span class="cstat-no" title="statement not covered" >r</span>eturn e.addClass(o.supported),e.css("position").match("sticky")}</span>},save:{lastScroll:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >m.lastScroll=e}</span>,elementScroll:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >m.elementScroll=e}</span>,positions:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >{height:d.height()},</span>t=<span class="cstat-no" title="statement not covered" >{margin:{top:parseInt(a.css("margin-top"),10),bottom:parseInt(a.css("margin-bottom"),10)},offset:a.offset(),width:a.outerWidth(),height:a.outerHeight()},</span>o=<span class="cstat-no" title="statement not covered" >{offset:i.offset(),height:i.outerHeight()};<span class="cstat-no" title="statement not covered" ></span>n.outerHeight();<span class="cstat-no" title="statement not covered" >m</span>.is.standardScroll()||(m.debug("Non-standard scroll. Removing scroll offset from element offset"),e.top=d.scrollTop(),e.left=d.scrollLeft(),t.offset.top+=e.top,o.offset.top+=e.top,t.offset.left+=e.left,o.offset.left+=e.left),m.cache={fits:t.height+u.offset&lt;=e.height,sameHeight:t.height==o.height,scrollContext:{height:e.height},element:{margin:t.margin,top:t.offset.top-t.margin.top,left:t.offset.left,width:t.width,height:t.height,bottom:t.offset.top+t.height},context:{top:o.offset.top,height:o.height,bottom:o.offset.top+o.height}},m.set.containerSize(),m.stick(),m.debug("Caching element positions",m.cache)}</span>},get:{direction:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >"down";<span class="cstat-no" title="statement not covered" ></span>return e=e||d.scrollTop(),m.lastScroll!==P&amp;&amp;(m.lastScroll&lt;e?t="down":m.lastScroll&gt;e&amp;&amp;(t="up")),t}</span>,scrollChange:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e=e||d.scrollTop(),m.lastScroll?e-m.lastScroll:0}</span>,currentElementScroll:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return m.elementScroll?m.elementScroll:m.is.top()?Math.abs(parseInt(a.css("top"),10))||0:Math.abs(parseInt(a.css("bottom"),10))||0}</span>,elementScroll:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e=e||d.scrollTop();v</span>ar t=<span class="cstat-no" title="statement not covered" >m.cache.element,</span>o=<span class="cstat-no" title="statement not covered" >m.cache.scrollContext,</span>n=<span class="cstat-no" title="statement not covered" >m.get.scrollChange(e),</span>i=<span class="cstat-no" title="statement not covered" >t.height-o.height+u.offset,</span>s=<span class="cstat-no" title="statement not covered" >m.get.currentElementScroll(),</span>r=<span class="cstat-no" title="statement not covered" >s+n;<span class="cstat-no" title="statement not covered" ></span>return s=m.cache.fits||r&lt;0?0:i&lt;r?i:r}</span>},remove:{lastScroll:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >delete m.lastScroll}</span>,elementScroll:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >delete m.elementScroll}</span>,minimumSize:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.css("min-height","")}</span>,offset:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.css("margin-top","")}</span>},set:{offset:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.verbose("Setting offset on element",u.offset),a.css("margin-top",u.offset)}</span>,containerSize:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >n.get(0).tagName;<span class="cstat-no" title="statement not covered" ></span>"HTML"===e||"body"==e?m.determineContainer():Math.abs(n.outerHeight()-m.cache.context.height)&gt;u.jitter&amp;&amp;(m.debug("Context has padding, specifying exact height for container",m.cache.context.height),n.css({height:m.cache.context.height}))}</span>,minimumSize:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >m.cache.element;<span class="cstat-no" title="statement not covered" ></span>n.css("min-height",e.height)}</span>,scroll:<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >m.debug("Setting scroll on element",e),m.elementScroll!=e&amp;&amp;(m.is.top()&amp;&amp;a.css("bottom","").css("top",-e),m.is.bottom()&amp;&amp;a.css("top","").css("bottom",e))}</span>,size:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >0!==m.cache.element.height&amp;&amp;0!==m.cache.element.width&amp;&amp;(p.style.setProperty("width",m.cache.element.width+"px","important"),p.style.setProperty("height",m.cache.element.height+"px","important"))}</span>},is:{standardScroll:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return d[0]==w}</span>,top:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.hasClass(o.top)}</span>,bottom:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.hasClass(o.bottom)}</span>,initialPosition:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!m.is.fixed()&amp;&amp;!m.is.bound()}</span>,hidden:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return!a.is(":visible")}</span>,bound:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.hasClass(o.bound)}</span>,fixed:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a.hasClass(o.fixed)}</span>},stick:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e||d.scrollTop(),</span>o=<span class="cstat-no" title="statement not covered" >m.cache,</span>n=<span class="cstat-no" title="statement not covered" >o.fits,</span>i=<span class="cstat-no" title="statement not covered" >o.sameHeight,</span>s=<span class="cstat-no" title="statement not covered" >o.element,</span>r=<span class="cstat-no" title="statement not covered" >o.scrollContext,</span>c=<span class="cstat-no" title="statement not covered" >o.context,</span>l=<span class="cstat-no" title="statement not covered" >m.is.bottom()&amp;&amp;u.pushing?u.bottomOffset:u.offset,</span>a=(<span class="cstat-no" title="statement not covered" >e={top:t+l,bottom:t+l+r.height},m.get.direction(e.top),n?0:m.get.elementScroll(e.top))</span>,f=<span class="cstat-no" title="statement not covered" >!n;<span class="cstat-no" title="statement not covered" ></span>0!==s.height&amp;&amp;!i&amp;&amp;(m.is.initialPosition()?e.top&gt;=c.bottom?(m.debug("Initial element position is bottom of container"),m.bindBottom()):e.top&gt;s.top&amp;&amp;(s.height+e.top-a&gt;=c.bottom?(m.debug("Initial element position is bottom of container"),m.bindBottom()):(m.debug("Initial element position is fixed"),m.fixTop())):m.is.fixed()?m.is.top()?e.top&lt;=s.top?(m.debug("Fixed element reached top of container"),m.setInitialPosition()):s.height+e.top-a&gt;=c.bottom?(m.debug("Fixed element reached bottom of container"),m.bindBottom()):f&amp;&amp;(m.set.scroll(a),m.save.lastScroll(e.top),m.save.elementScroll(a)):m.is.bottom()&amp;&amp;(e.bottom-s.height&lt;=s.top?(m.debug("Bottom fixed rail has reached top of container"),m.setInitialPosition()):e.bottom&gt;=c.bottom?(m.debug("Bottom fixed rail has reached bottom of container"),m.bindBottom()):f&amp;&amp;(m.set.scroll(a),m.save.lastScroll(e.top),m.save.elementScroll(a))):m.is.bottom()&amp;&amp;(e.top&lt;=s.top?(m.debug("Jumped from bottom fixed to top fixed, most likely used home/end button"),m.setInitialPosition()):u.pushing?m.is.bound()&amp;&amp;e.bottom&lt;=c.bottom&amp;&amp;(m.debug("Fixing bottom attached element to bottom of browser."),m.fixBottom()):m.is.bound()&amp;&amp;e.top&lt;=c.bottom-s.height&amp;&amp;(m.debug("Fixing bottom attached element to top of browser."),m.fixTop())))}</span>,bindTop:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.debug("Binding element to top of parent container"),m.remove.offset(),a.css({left:"",top:"",marginBottom:""}).removeClass(o.fixed).removeClass(o.bottom).addClass(o.bound).addClass(o.top),u.onTop.call(p),u.onUnstick.call(p)}</span>,bindBottom:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.debug("Binding element to bottom of parent container"),m.remove.offset(),a.css({left:"",top:""}).removeClass(o.fixed).removeClass(o.top).addClass(o.bound).addClass(o.bottom),u.onBottom.call(p),u.onUnstick.call(p)}</span>,setInitialPosition:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.debug("Returning to initial position"),m.unfix(),m.unbind()}</span>,fixTop:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.debug("Fixing element to top of page"),u.setSize&amp;&amp;m.set.size(),m.set.minimumSize(),m.set.offset(),a.css({left:m.cache.element.left,bottom:"",marginBottom:""}).removeClass(o.bound).removeClass(o.bottom).addClass(o.fixed).addClass(o.top),u.onStick.call(p)}</span>,fixBottom:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.debug("Sticking element to bottom of page"),u.setSize&amp;&amp;m.set.size(),m.set.minimumSize(),m.set.offset(),a.css({left:m.cache.element.left,bottom:"",marginBottom:""}).removeClass(o.bound).removeClass(o.top).addClass(o.fixed).addClass(o.bottom),u.onStick.call(p)}</span>,unbind:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.is.bound()&amp;&amp;(m.debug("Removing container bound position on element"),m.remove.offset(),a.removeClass(o.bound).removeClass(o.top).removeClass(o.bottom))}</span>,unfix:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.is.fixed()&amp;&amp;(m.debug("Removing fixed position on element"),m.remove.minimumSize(),m.remove.offset(),a.removeClass(o.fixed).removeClass(o.top).removeClass(o.bottom),u.onUnstick.call(p))}</span>,reset:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >m.debug("Resetting elements position"),m.unbind(),m.unfix(),m.resetCSS(),m.remove.offset(),m.remove.lastScroll()}</span>,resetCSS:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a.css({width:"",height:""}),n.css({height:""})}</span>,setting:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(T.isPlainObject(e))<span class="cstat-no" title="statement not covered" >T.extend(!0,u,e);e</span>lse{<span class="cstat-no" title="statement not covered" >if(t===P)<span class="cstat-no" title="statement not covered" >return u[e];<span class="cstat-no" title="statement not covered" >u</span></span>[e]=t}</span>}</span>,internal:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >if(T.isPlainObject(e))<span class="cstat-no" title="statement not covered" >T.extend(!0,m,e);e</span>lse{<span class="cstat-no" title="statement not covered" >if(t===P)<span class="cstat-no" title="statement not covered" >return m[e];<span class="cstat-no" title="statement not covered" >m</span></span>[e]=t}</span>}</span>,debug:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!u.silent&amp;&amp;u.debug&amp;&amp;(u.performance?m.performance.log(arguments):(m.debug=Function.prototype.bind.call(console.info,console,u.name+":"),m.debug.apply(console,arguments)))}</span>,verbose:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >!u.silent&amp;&amp;u.verbose&amp;&amp;u.debug&amp;&amp;(u.performance?m.performance.log(arguments):(m.verbose=Function.prototype.bind.call(console.info,console,u.name+":"),m.verbose.apply(console,arguments)))}</span>,error:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >u.silent||(m.error=Function.prototype.bind.call(console.error,console,u.name+":"),m.error.apply(console,arguments))}</span>,performance:{log:<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t,o;<span class="cstat-no" title="statement not covered" >u.performance&amp;&amp;(o=(t=(new Date).getTime())-(C||t),C=t,S.push({Name:e[0],Arguments:[].slice.call(e,1)||"",Element:p,"Execution Time":o})),clearTimeout(m.performance.timer),m.performance.timer=setTimeout(m.performance.display,0)}</span>,display:<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >u.name+":",</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>C=!1,clearTimeout(m.performance.timer),T.each(S,<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >o+=t["Execution Time"]}</span>),e+=" "+o+"ms",x&amp;&amp;(e+=" '"+x+"'"),(console.group!==P||console.table!==P)&amp;&amp;0&lt;S.length&amp;&amp;(console.groupCollapsed(e),console.table?console.table(S):T.each(S,<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >console.log(t.Name+": "+t["Execution Time"]+"ms")}</span>),console.groupEnd()),S=[]}</span>},invoke:<span class="fstat-no" title="function not covered" >fu</span>nction(n,e,t){var i,s,o,r=<span class="cstat-no" title="statement not covered" >h;<span class="cstat-no" title="statement not covered" ></span>return e=e||z,t=p||t,"string"==typeof n&amp;&amp;r!==P&amp;&amp;(n=n.split(/[\. ]/),i=n.length-1,T.each(n,<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){var o=<span class="cstat-no" title="statement not covered" >e!=i?t+n[e+1].charAt(0).toUpperCase()+n[e+1].slice(1):n;<span class="cstat-no" title="statement not covered" ></span>if(T.isPlainObject(r[o])&amp;&amp;e!=i)<span class="cstat-no" title="statement not covered" >r=r[o];e</span>lse{<span class="cstat-no" title="statement not covered" >if(r[o]!==P)<span class="cstat-no" title="statement not covered" >return s=r[o],!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!T.isPlainObject(r[t])||e==i)<span class="cstat-no" title="statement not covered" >return r[t]!==P&amp;&amp;(s=r[t]),!1;<span class="cstat-no" title="statement not covered" >r</span></span>=r[t]}</span>}</span>)),T.isFunction(s)?o=s.apply(t,e):s!==P&amp;&amp;(o=s),T.isArray(v)?v.push(o):v!==P?v=[v,o]:o!==P&amp;&amp;(v=o),s}</span>},k?(h===P&amp;&amp;m.initialize(),m.invoke(y)):(h!==P&amp;&amp;h.invoke("destroy"),m.initialize())}</span>),v!==P?v:this}</span>,T.fn.sticky.settings={name:"Sticky",namespace:"sticky",silent:!1,debug:!1,verbose:!0,performance:!0,pushing:!1,context:!1,container:!1,scrollContext:w,offset:0,bottomOffset:0,jitter:5,setSize:!0,observeChanges:!1,onReposition:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onScroll:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onStick:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onUnstick:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onTop:<span class="fstat-no" title="function not covered" >fu</span>nction(){},onBottom:<span class="fstat-no" title="function not covered" >fu</span>nction(){},error:{container:"Sticky element must be inside a relative container",visible:"Element is hidden, you must call refresh after element becomes visible. Use silent setting to surpress this warning in production.",method:"The method you called is not defined.",invalidContext:"Context specified does not exist",elementSize:"Sticky element is larger than its container, cannot create sticky."},className:{bound:"bound",fixed:"fixed",supported:"native",top:"top",bottom:"bottom"}}}</span>(jQuery,window,document);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Sat Feb 29 2020 00:35:45 GMT-0400 (GMT-04:00)
            </div>
        </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    